---
layout: post
title: 虚拟化技术-Docker VS Virtual Machines
categories: docker
---

## 背景
在虚拟化技术之前，部署一个app需要先有物理服务器，然后在服务器上安装操作系统，最后将app部署在操作系统之上。这种模式具有部署慢、成本高、资源浪费(CPU/内存/硬盘等)、难于迁移和扩展、可能会被限定硬件厂商的缺点。

以虚拟机为代表的虚拟化技术出现后，上述模式的缺点有所改善。其在操作系统之上，先通过Hypervisor对物理资源进行虚拟化，然后在虚拟化后的资源上安装虚拟机(包括操作系统和app)。该种模式可实现一个物理机部署多个app，每个app独立运行在一个vm里。其具有资源池化、易扩展、易云化的优点，但是每个虚拟机都是一个完整的操作系统，资源耗费比较多。

而随着app的**技术栈的多样性以及硬件环境的多样性**，且**开发和运维之间没有统一的标准**。为了解决上述问题，以**容器化(container)** 为代表的虚拟化技术应用而生。其在开发与运维间提供了一种标准。对于开发人员，其可将任何有效载荷封装为轻巧、便携、自给自足的容器；对于运维人员，其使用标准操作对容器进行操作，并可以在几乎任何硬件平台上一致地运行。

## 对比
docker是一种**容器化**技术的实现，它与传统的虚拟机(virtual machine)一样，可实现**资源和环境的隔离**。两者实现虚拟化的方式不同，具体对比如下图所示：

![png](/assets/images/vm/docker-vm.png)

传统的虚拟机首先通过**Hypervisor层**对物理硬件进行虚拟化，然后在虚拟的硬件资源上安装**从操作系统(guest os)**，最后将相关**应用**运行在从操作系统上。**其中APP+BINS/LIBS+Guest OS为虚拟机**

而docker不像虚拟机那样利用Hypervisor和guest os实现资源与环境的隔离，其仅通过一个docker daemon/engine来实现**资源限制与环境隔离(终极目标是app的隔离)**(主要利用linux内核本身支持的容器方式来实现这一功能)，其中**APP+BINS/LIBS为容器(container)**。 **docker daemon/engine可以简单看成对Linux内核中的NameSpace、Cgroup、镜像管理文件系统操作的封装。** 简单的说，docker利用namespace实现**系统环境的隔离**；利用Cgroup实现**资源限制**；利用镜像实现**根目录环境的隔离**。 

## 小结
由上述分析可知：
- 虚拟机
    - 物理资源层面的隔离(隔离的更彻底，对硬件进行虚拟化，app运行在虚拟的硬件上)
    - 不同虚拟机间系统独立，笨重(G)，启动慢(min)，运行效率低(低于物理硬件)，一台主机可创建有限的虚拟机，资源利用率低
- docker
    - app层面的隔离(隔离性较差，app直接运行在宿主机的内核之上，容器内没有自己的内核，也没进行硬件虚拟化，)
    - 与宿主机共享系统内核，轻快(M)，启动快(s)，运行效率高(接近物理硬件)，一台主机可创建大量容器，资源利用率高
    
说明：
- docker的安全性不高，无法分辨执行指令的用户。A用户可以删除B用户创建的容器，存在一定的安全风险
- docker版本在快速更新中，存在版本兼容问题    
## 参考
* [Docker与虚拟机的区别](https://www.jianshu.com/p/d3006b8a22ee)

* [Docker和虚拟机的对比](https://www.cnblogs.com/jie-fang/p/10279629.html)

* [Docker教程之二Docker和传统虚拟化对比](https://blog.csdn.net/xingfei_work/article/details/81029003)